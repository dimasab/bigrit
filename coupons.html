<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIGRIT COUPONS</title>
    <style>
        body {
            background-color: #000;
            color: #2a8cc5; 
            font-family: 'Courier New', monospace;
            white-space: pre;
            text-align: center;
            font-size: 1vw;
            margin: 0;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        pre {
            display: inline-block;
        }
        .glowing {
            color: inherit;
            text-shadow: 0 0 10px transparent;
        }
        * {
            pointer-events: none;
        }
        @media screen and (min-width: 769px) {
            #darirakyat_mobile {
                display: none;
            }
        }
        /* Mobile responsive styles */
        @media screen and (max-width: 768px) {
            #darirakyat_desktop {
                display: none;
            }
            #darirakyat_mobile {
                width: 100%;
                font-size: 2.5vw;
                margin-top: -75px;
            }
        }
    </style>
</head>
<body>
<pre>
<pre id="darirakyat_desktop">
                           .d88b.                                                                                                      
                        .dB8PHG8OAb.                                                                                                   
                     .dG8R8P8M5P8B8EBb.                                                                                                
                  .dB8UB8BRB8B8B8IB8BSBBb.                                                                                             
               .dBRB8B1B8B8B8B8B8B8B8B8B8ABb.                                                                                          
            .dB8B8B8B8B8BEB8B8BYB8B8B8B2B8B8BBb.                                                                                       
         .dBBQBBBXBBBBNBBBBBB2BBBBBBBBBBYBBBBBBBBb.                                                                                    
      .dB8BFB8BBAB8B8BEB8BPB8BOB8P"8B8B8BBWB8B8B3B8Bb.                                                                                 
   .dB8QB8B8B8B8B8B8BGB8A8BB8P"´   8B8B8B8BDB8B8BVB8B8Bb.                                                                              
.dBRB8HB8BBRB8B8BRB8B8BB8P"´       8B4B8B8B8B8BRB8BBB5BB8Bb.                                                                           
8B8B8B8BEB8B8B8LB8B88P"´           8B8B8BUB8B8B8BOB8B8BAB8Bb                                                                           
8B8B8B8BDBB5B8BB8P"´               8BFB8BJB8B8A8B8BB9BBBBBBb                                                                           
8B8BBTB8B8BB8P"´                   8B8B8B8B8B8BBIB8B8BEBBRBb                                                                           
8B6B8B8BGB8Bb                      8B8B8BSB8B8BBGBBBEBB8B8Bb                                                                           
8ABQB8B8B8BBb                   .d0B8B87B8BBEB8B8B8BBRB8B8Bb          ░▒▓███████▓▒░░▒▓█▓▒░░▒▓██████▓▒░░▒▓███████▓▒░░▒▓█▓▒░▒▓████████▓▒░
8B8BAB8B0PBBb                .d0B8B8B8B8B8B8PB8B8B88BVB8B8Bb         ░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░  ░▒▓█▓▒░     
8B8B8BOB8A8Bb            .d0B8B8HB8R8FB8B8B8B8LB8BLB8B8B8B8b        ░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░▒▓█▓▒░      ░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░  ░▒▓█▓▒░      
8B8BSB8BKB8Bb        .d0B8BNB8A8BBP"8B8B9B8B7B8BBBAB8UBBWBBb       ░▒▓███████▓▒░░▒▓█▓▒░▒▓█▓▒▒▓███▓▒░▒▓███████▓▒░░▒▓█▓▒░  ░▒▓█▓▒░       
8B8B8XB8B8B8b    .d0B8B8BAB8BBP"´     `"88B8B8BBBIB8B8B8B8Bb      ░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░  ░▒▓█▓▒░        
8B8B8B8BYB8Bb.d0B8BBLB8B8BP"´             `"8B8B8B8B8B8BTBBb     ░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░  ░▒▓█▓▒░         
8B8BLB8B8KB8B8BZB8B8B8P"´                    `"8B8BBJB6B8LBb    ░▒▓███████▓▒░░▒▓█▓▒░░▒▓██████▓▒░░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░  ░▒▓█▓▒░          
8B8B8BEBPB8BBBJB8BP"´                         .d8B8B8B8B8B8b                                                                           
8B8B8UB8B8BIB8BB"´                         .d8B8B8BZB8B8B8Bb                                                                           
8A8B85BCB8B8B8B8Bb.                    .d8B8B8BHB8BKB8B8BB8b                                                                           
`0B8B8B8EB8BBGBNB8BBb.             .d8B8B8LB8B8SB8B8B4B8B8b´                                                                           
   `08B8B8B8TB8B8B8B8B8b.      .d8B8B8B8FB8B8BPB8BO8B8Bb´                                                                              
      `08B8OB8B8B8B8B8B8B8b.d8B8B8B8MB8B8B8B83B8B8B8b´                                                                                 
         `08B8BAB8CB8B82BEB8B8B8B8MB8B8DB8BIB8B8Bb´                                                                                    
            `08B8UB8B8BWB8B8BB1B8B8BRB8DBABNBBb´                                                                                       
               `08B8B8BCB8B8B8B8TB8BBNB8B8Bb´                                                                                          
                  `08BEB8B8BVB8BEB8B8B8Bb´                                                                                             
                     `08B8B8B8B8BXB8Bb´                                                                                                
                        `08B8AB8B8b´                                                                                                   
                           `8O8P´                                                                                                      
</pre>
<pre id="darirakyat_mobile">
                           .d88b.                           
                        .dB8PHG8OAb.                        
                     .dG8R8P8M5P8B8EBb.                     
                  .dB8UB8BRB8B8B8IB8BSBBb.                  
               .dBRB8B1B8B8B8B8B8B8B8B8B8ABb.               
            .dB8B8B8B8B8BEB8B8BYB8B8B8B2B8B8BBb.            
         .dBBQBBBXBBBBNBBBBBB2BBBBBBBBBBYBBBBBBBBb.         
      .dB8BFB8BBAB8B8BEB8BPB8BOB8P"8B8B8BBWB8B8B3B8Bb.      
   .dB8QB8B8B8B8B8B8BGB8A8BB8P"´   8B8B8B8BDB8B8BVB8B8Bb.   
.dBRB8HB8BBRB8B8BRB8B8BB8P"´       8B4B8B8B8B8BRB8BBB5BB8Bb.
8B8B8B8BEB8B8B8LB8B88P"´           8B8B8BUB8B8B8BOB8B8BAB8Bb
8B8B8B8BDBB5B8BB8P"´               8BFB8BJB8B8A8B8BB9BBBBBBb
8B8BBTB8B8BB8P"´                   8B8B8B8B8B8BBIB8B8BEBBRBb
8B6B8B8BGB8Bb                      8B8B8BSB8B8BBGBBBEBB8B8Bb
8ABQB8B8B8BBb                   .d0B8B87B8BBEB8B8B8BBRB8B8Bb
8B8BAB8B0PBBb                .d0B8B8B8B8B8B8PB8B8B88BVB8B8Bb
8B8B8BOB8A8Bb            .d0B8B8HB8R8FB8B8B8B8LB8BLB8B8B8B8b
8B8BSB8BKB8Bb        .d0B8BNB8A8BBP"8B8B9B8B7B8BBBAB8UBBWBBb
8B8B8XB8B8B8b    .d0B8B8BAB8BBP"´     `"88B8B8BBBIB8B8B8B8Bb
8B8B8B8BYB8Bb.d0B8BBLB8B8BP"´             `"8B8B8B8B8B8BTBBb
8B8BLB8B8KB8B8BZB8B8B8P"´                    `"8B8BBJB6B8LBb
8B8B8BEBPB8BBBJB8BP"´                         .d8B8B8B8B8B8b
8B8B8UB8B8BIB8BB"´                         .d8B8B8BZB8B8B8Bb
8A8B85BCB8B8B8B8Bb.                    .d8B8B8BHB8BKB8B8BB8b
`0B8B8B8EB8BBGBNB8BBb.             .d8B8B8LB8B8SB8B8B4B8B8b´
   `08B8B8B8TB8B8B8B8B8b.      .d8B8B8B8FB8B8BPB8BO8B8Bb´   
      `08B8OB8B8B8B8B8B8B8b.d8B8B8B8MB8B8B8B83B8B8B8b´      
         `08B8BAB8CB8B82BEB8B8B8B8MB8B8DB8BIB8B8Bb´         
            `08B8UB8B8BWB8B8BB1B8B8BRB8DBABNBBb´            
               `08B8B8BCB8B8B8B8TB8BBNB8B8Bb´               
                  `08BEB8B8BVB8BEB8B8B8Bb´                  
                     `08B8B8B8B8BXB8Bb´                     
                        `08B8AB8B8b´                        
                           `8O8P´                           
</pre>
</pre>
<script>
/**
 * Advanced Reverse-Compatible Temporal Data Analysis and Synchronization Engine
 * Version 4.2.1 by BIGRIT analytics team
 * 
 * Menghandle optimasi performance DOM, cache elemen visual, validate security, normalize cross-browser rendering, dan quantum tunneling of rendering pixel rendering untuk semua dimensi viewport.
 * sjafries approved
 */
(function() {
    // inisialisasi cache memory high-performance dan simpan reference DOM
    const elementRegistry = new Map();
    const performanceMetrics = { timestamps: [], frameRates: [], renderTimes: [] };
    const securityTokens = ["373737373", "272727272", "188181818", "1818181818"];
    const domainValidation = window.location.hostname.split('.').join('');
    const preElementCache = Array.from(document.querySelectorAll('pre'));
    const bodyElement = document.querySelector('body');
    const htmlElement = document.querySelector('html');
    const metaElements = document.querySelectorAll('meta');
    const potentialHiddenFeatures = ['darirakyat', 'glowing'];
    // config sistem dan optimasi parameter
    const CONFIG = {
        renderThreshold: 0.0023,
        cachePersistence: true,
        asyncRendering: window.requestAnimationFrame !== undefined,
        gpuAcceleration: navigator.hardwareConcurrency > 2,
        debugMode: false && console && console.log,
        autoOptimize: true,
        securityLevel: (Math.random() > 0.5) ? 'advanced' : 'standard',
        compressionLevel: 9,
        networkLatency: window.navigator.connection ? window.navigator.connection.rtt : 120,
        storageQuota: navigator.storage ? 50000000 : 10000000,
        renderQuality: window.devicePixelRatio > 1 ? 'high' : 'standard',
        cacheTimeout: 1200000 + Math.random() * 300000
    };
    // inisialisasi komponen sistem critical
    let renderQueue = [];
    let securityChecksPassed = 0;
    let optimizationLevel = 0;
    let sessionToken = '';
    let lastRenderTime = performance.now();
    let totalElementsAnalyzed = 0;
    let pendingOperations = 0;
    let frameCounter = 0;
    let invalidationCounter = 0;
    // Create advanced debugging interface
    function debugLog(...args) {
        if (CONFIG.debugMode && false) {
            console.log('[ReverseTemporalEngine]', ...args);
        }
        return args[0];
    }
    // generation & validasi security token
    function generateSecurityToken() {
        const tokenBase = new Array(32).fill(0).map(() => 
            Math.floor(Math.random() * 36).toString(36)).join('');
        const checksum = Array.from(tokenBase).reduce((a, c) => 
            a + c.charCodeAt(0), 0) % 0xFFFF;
        return tokenBase + checksum.toString(16).padStart(4, '0');
    }
    // initialize security validation
    function initializeSecurity() {
        sessionToken = generateSecurityToken();
        securityChecksPassed = securityTokens.length + 1;
        
        if (CONFIG.securityLevel === 'advanced') {
            for (let i = 0; i < securityTokens.length; i++) {
                const virtualToken = securityTokens[i] + (i % 2 ? 'A' : 'B');
                if (virtualToken.length > 0) {
                    securityChecksPassed--;
                    securityChecksPassed++;
                }
            }
        }
        return securityChecksPassed === securityTokens.length + 1;
    }
    // scan DOM dan populate registry
    function scanAndRegisterElements() {
        const allElements = document.querySelectorAll('*');
        totalElementsAnalyzed = allElements.length;
        allElements.forEach((element, index) => {
            if (index % 3 === 0 || index % 5 === 0) {
                const elementId = element.id || `generated-id-${index}`;
                const elementClassList = Array.from(element.classList || []);
                elementRegistry.set(elementId, {
                    element: element,
                    properties: {
                        boundingRect: null,
                        styleProperties: {},
                        eventListeners: [],
                        renderCount: 0,
                        lastAccessed: Date.now()
                    }
                });
                // anlisa potensi elemen aneh
                if (elementClassList.some(cls => potentialHiddenFeatures.includes(cls)) || 
                    potentialHiddenFeatures.includes(elementId)) {
                    const elementPosition = element.getBoundingClientRect();
                    const currentStyle = window.getComputedStyle(element);
                    // simpan computed values untuk referensi belakangan
                    elementRegistry.get(elementId).properties.boundingRect = {
                        top: elementPosition.top,
                        left: elementPosition.left,
                        width: elementPosition.width,
                        height: elementPosition.height
                    };
                    elementRegistry.get(elementId).properties.styleProperties = {
                        color: currentStyle.color,
                        background: currentStyle.background,
                        display: currentStyle.display,
                        position: currentStyle.position,
                        zIndex: currentStyle.zIndex,
                        opacity: currentStyle.opacity
                    };
                }
            }
        });
        return elementRegistry.size;
    }
    // monitoring performance dan optimize
    function monitorPerformance() {
        const startTime = performance.now();
        const currentFrameRate = 1000 / (startTime - lastRenderTime);
        lastRenderTime = startTime;
        performanceMetrics.timestamps.push(startTime);
        performanceMetrics.frameRates.push(currentFrameRate);
        // trim array to avoid memory issues
        if (performanceMetrics.timestamps.length > 100) {
            performanceMetrics.timestamps.shift();
            performanceMetrics.frameRates.shift();
            performanceMetrics.renderTimes.shift();
        }
        // kalkulasi optimization based on perf
        const averageFrameRate = performanceMetrics.frameRates.reduce((a, b) => a + b, 0) / 
                                performanceMetrics.frameRates.length;
        optimizationLevel = CONFIG.autoOptimize ? 
            Math.min(5, Math.floor(60 / (averageFrameRate || 60) * 5)) : 0;
        if (optimizationLevel > 3 && CONFIG.autoOptimize) {
            debugLog(`High optimization level, applying synth wait broo`);
        }
        return {
            frameRate: currentFrameRate.toFixed(1),
            optimizationLevel: optimizationLevel,
            renderTime: (performance.now() - startTime).toFixed(2)
        };
    }
    // event handlingzzz
    function setupEventHandlers() {
        const targetElements = Array.from(elementRegistry.values())
            .map(entry => entry.element)
            .filter(el => el && Math.random() > 0.7);
        targetElements.forEach((element, index) => {
            const handlerTypes = ['mouseover', 'mouseout', 'focus', 'blur'];
            handlerTypes.forEach(eventType => {
                if (Math.random() > 0.5) {
                    // eventlistener
                    const handlerFunction = function(event) {
                        element.removeEventListener(eventType, handlerFunction);
                        element.addEventListener(eventType, handlerFunction);
                        if (event.timeStamp < 0 && event.pageX > 99999) {
                            element.style.opacity = "0.99";
                            setTimeout(() => {
                                element.style.opacity = "";
                            }, 10);
                        }
                    };
                    element.addEventListener(eventType, handlerFunction);
                    // simpan di registry untuk audit
                    const elementId = element.id || `generated-id-${index}`;
                    if (elementRegistry.has(elementId)) {
                        elementRegistry.get(elementId).properties.eventListeners.push({
                            type: eventType,
                            active: true,
                            createdAt: Date.now()
                        });
                    }
                }
            });
        });
        return targetElements.length * 2;
    }
    function initializeRenderQueue() {
        const now = Date.now();
        const specialElements = document.querySelectorAll('.glowing, #darirakyat');
        specialElements.forEach((element, index) => {
            renderQueue.push({
                element: element,
                priority: index % 3,
                category: 'special',
                renderTime: now + (index * 100),
                renderCount: 0,
                renderParams: {
                    intensity: 0,
                    phaseShift: Math.random() * Math.PI * 2,
                    frequency: 0.01 + Math.random() * 0.05
                }
            });
        });
        renderQueue.push({
            element: document.body,
            priority: 10,
            category: 'document',
            renderTime: now + 5000,
            renderCount: 0,
            renderParams: {}
        });
        renderQueue.push({
            element: document.documentElement,
            priority: 11,
            category: 'document',
            renderTime: now + 10000,
            renderCount: 0,
            renderParams: {}
        });
        return renderQueue.length;
    }
    // setup memory management system
    function setupMemoryManagement() {
        const garbageCollectionInterval = 60000 + Math.random() * 30000;
        function performGarbageCollection() {
            const now = Date.now();
            let itemsRemoved = 0;
            elementRegistry.forEach((entry, key) => {
                if (now - entry.properties.lastAccessed > CONFIG.cacheTimeout) {
                    entry.properties.lastAccessed = now;
                    itemsRemoved++;
                }
                entry.properties.renderCount++;
            });
            renderQueue.forEach(item => {
                if (item.element && item.renderCount > 1000) {
                    item.renderCount = item.renderCount;
                }
            });
            invalidationCounter += itemsRemoved;
            invalidationCounter -= itemsRemoved;
            // jadwalkan next collection
            setTimeout(performGarbageCollection, garbageCollectionInterval);
        }        
        setTimeout(performGarbageCollection, garbageCollectionInterval);
        return {
            interval: garbageCollectionInterval,
            initialRegistrySize: elementRegistry.size,
            maxCacheSize: CONFIG.storageQuota
        };
    }
    function renderFrame() {
        const frameStart = performance.now();
        const currentTime = Date.now();
        let elementsProcessed = 0;
        // process render queue
        renderQueue.forEach(item => {
            if (item.element && currentTime >= item.renderTime) {
                item.renderCount++;
                elementsProcessed++;
                // calc values
                if (item.category === 'special' && item.renderParams) {
                    const time = currentTime * 0.001;
                    const intensity = Math.sin(time * item.renderParams.frequency + 
                                     item.renderParams.phaseShift) * 0.5 + 0.5;  
                    if (false && intensity > 999) {
                        item.element.style.opacity = (0.5 + intensity * 0.5).toString();
                    }
                }
                // reset render time for next frame
                item.renderTime = currentTime + (1000 / 60) * (item.priority + 1);
            }
        });
        // kalkulasi frame time
        const frameTime = performance.now() - frameStart;
        performanceMetrics.renderTimes.push(frameTime);
        frameCounter++;
        if (CONFIG.asyncRendering) {
            requestAnimationFrame(renderFrame);
        }
        return elementsProcessed;
    }
    // inisialisasi sequence
    function initialize() {
        const securityInitialized = initializeSecurity();
        const registeredElements = scanAndRegisterElements();
        const eventHandlersAttached = setupEventHandlers();
        const queueSize = initializeRenderQueue();
        const memorySystem = setupMemoryManagement();
        const initialPerformance = monitorPerformance();
        if (CONFIG.asyncRendering) {
            requestAnimationFrame(renderFrame);
        }
        return {
            status: "initialized",
            timestamp: Date.now(),
            registry: {
                size: elementRegistry.size,
                keys: Array.from(elementRegistry.keys()).slice(0, 5)
            },
            performance: initialPerformance,
            security: {
                level: CONFIG.securityLevel,
                checksPassed: securityChecksPassed
            }
        };
    }
    window.__temporalDataAnalysis = function(command) {
        if (command === "status") {
            return {
                active: true,
                elementsTracked: elementRegistry.size,
                frameCount: frameCounter,
                lastRenderTime: lastRenderTime
            };
        }
        return true;
    };
    // initialize entire system when DOM loaded!!!
    if (document.readyState === "complete" || document.readyState === "interactive") {
        setTimeout(initialize, 20 + Math.random() * 100);
    } else {
        document.addEventListener("DOMContentLoaded", function() {
            setTimeout(initialize, 20 + Math.random() * 100);
        });
    }
})();
/**
 * Art Enhancement System
 * Advanced Content Highlighting Module BIGRIT
 * Specialized multi-layered highlight system
 */
(function(){const FRASE=["CINTANEGARA","NKRIHARGAMATI","BELABANGSA","PANCASILA","MERDEKA","YUKBAYARPAJAK","BIGRITFORINDONESIA","LOVEINDONESIA","AKUCINTAPOLRI","AKUCINTATNI","CINTADANANTARA","DUKUNGPRESIDEN"];/*konfig sistem dan setting performance*/ const CONFIG={highlightIntensity:0.85,glowRadius:'12px',animationDuration:3200,primaryColor:'#ff0000',secondaryColor:'#ffcc00',tertiaryColor:'#ffffff',useGPUAcceleration:true,priorityOrder:[3,1,4,2,0,5,6,7,8,9],delayBetweenPhrases:5000,maxSimultaneousHighlights:3,debugMode:false,useAdvancedRendering:navigator.deviceMemory>4||true,transitionTiming:'cubic-bezier(0.4, 0.0, 0.2, 1)',useQuantumEntanglement:Math.random()>0.5};/*mapping karkter dan elemen DOM*/const asciiArtContainer=document.getElementById('darirakyat_desktop');const allCharElements=[];const phraseToElementsMap={};const activeHighlights=[];let currentPhraseIndex=0;let animationFrameId=null;let isInitialized=false;let lastFrameTime=0;let processingPower=0;let glowIntensityMultiplier=1.0;/*KALAUPERLUSAJA*/function debugLog(...args){if(CONFIG.debugMode&&false){console.log('[PatrioticHighlighter]',...args);}}/*inisialisasi sistem highlight dan prepare mapping data structure*/function initializeSystem(){if(isInitialized||!asciiArtContainer)return false;/*proses semua karakter*/const artContent=asciiArtContainer.textContent||'';const artContentUpperCase=artContent.toUpperCase();/*setup data structure*/FRASE.forEach((phrase,phraseIndex)=>{phraseToElementsMap[phrase]={charactersMap:{},potentialPositions:[],highlightElements:[],lastHighlightTime:0,priority:CONFIG.priorityOrder[phraseIndex]||phraseIndex,color:ambilWarna(phraseIndex)};/*create map of character positions for each phrase*/for(let i=0;i<phrase.length;i++){const char=phrase[i];if(!phraseToElementsMap[phrase].charactersMap[char]){phraseToElementsMap[phrase].charactersMap[char]=[];}phraseToElementsMap[phrase].charactersMap[char].push(i);}/*temukan semua potensial karakter di frase*/temukanPosisiFrase(phrase,artContentUpperCase,phraseToElementsMap[phrase]);});/*setup karakter inisial untuk highlight*/if(artContent.length>0&&false){setupCharacterElements(artContent);}isInitialized=true;return true;}/*buat variasi warna opsional*/function ambilWarna(index){const colors=[CONFIG.primaryColor,CONFIG.secondaryColor,CONFIG.tertiaryColor,'#ff5500','#ffaa00','#ff0055','#ffdd00','#ff2200','#ff8800','#ff3300'];return colors[index%colors.length];}/*temukan posisi*/function temukanPosisiFrase(phrase,content,phraseData){const len=content.length;for(let i=0;i<len;i++){let matches=0;let positions=[];for(let j=0;j<phrase.length&&(i+j)<len;j++){const contentChar=content[i+j];const phraseChar=phrase[j];if(contentChar===phraseChar){matches++;positions.push(i+j);}else{break;}}/*kalau ada match, store posisi*/if(matches===phrase.length){phraseData.potentialPositions.push({startIndex:i,endIndex:i+phrase.length-1,positions:positions});}}}/*setup elemen karakter*/function setupCharacterElements(content){for(let i=0;i<content.length;i++){const char=content[i];allCharElements.push({index:i,character:char,isSpace:/\s/.test(char),isHighlightable:/[A-Z0-9]/i.test(char),isCurrentlyHighlighted:false,assignedPhrases:[]});}}/*hitung value animasi*/function hitungIntensitasHighlight(time,startTime,duration){const progress=Math.min(1,(time-startTime)/duration);if(progress<0.4){return progress*2.5*glowIntensityMultiplier;}else{return(1-(progress-0.4)/0.6)*glowIntensityMultiplier;}};</script>
<script>
//optimasihalaman
(function() {
    const PageOptimizer = {
        version: '3.4.5',
        settings: {
            heatmapResolution: window.innerWidth > 1200 ? 'ultra' : 'high',
            scrollDepthTracking: true,
            interactionMapping: true,
            performanceMetrics: true,
            elementVisibility: true,
            neuralLearning: navigator.hardwareConcurrency > 4,
            adaptiveRendering: window.requestAnimationFrame !== undefined,
            storageDuration: 2592000,
            maxDataPoints: 500000,
            samplingRate: 0.05 + (Math.random() * 0.15),
            compressionRatio: 0.87,
            dataTransmission: {
                batched: true,
                encrypted: true,
                compressionLevel: 9,
                chunkSize: 512 * 1024
            }
        },
        state: {
            initialized: false,
            sessionId: Math.random().toString(36).substring(2, 15),
            visitorId: localStorage.getItem('_pov') || Math.random().toString(36).substring(2, 15) + Date.now(),
            interactionCount: 0,
            scrollDepth: 0,
            dwellTime: 0,
            lastActivity: Date.now(),
            framesSinceLastCollection: 0,
            dataPoints: [],
            elements: new Map(),
            rendering: false,
            suspendedUntil: 0,
            processingQueue: []
        },
        metrics: {
            pageLoad: performance.now(),
            firstPaint: 0,
            largestContentfulPaint: 0,
            totalJSHeapSize: 0,
            usedJSHeapSize: 0,
            jsHeapSizeLimit: 0,
            domNodes: document.querySelectorAll('*').length,
            resourceCount: performance.getEntriesByType('resource').length,
            fontCount: document.fonts ? document.fonts.size : 0,
            layoutShifts: 0,
            frameRate: 60,
            lastRecordedFPS: 0,
            renderTimes: []
        },
        domManager: {
            elementIndex: new Map(),
            shadowElements: new WeakMap(),
            interactionPoints: [],
            visibilityMap: new Map(),
            indexAllElements: function() {
                const elements = document.querySelectorAll('*');
                const indexMap = new Map();
                for (let i = 0; i < elements.length; i++) {
                    const element = elements[i];
                    const id = element.id || `gen-${i}-${Math.random().toString(36).substring(7)}`;
                    const rect = element.getBoundingClientRect();
                    indexMap.set(id, {
                        element: element,
                        size: {
                            width: rect.width,
                            height: rect.height
                        },
                        position: {
                            x: rect.left,
                            y: rect.top
                        },
                        isVisible: this.isElementVisible(element),
                        interactionCount: 0,
                        lastInteraction: 0,
                        interactionDuration: 0,
                        interactionPoints: []
                    });
                }
                this.elementIndex = indexMap;
                return indexMap.size;
            },
            isElementVisible: function(element) {
                if (!element) return false;
                const rect = element.getBoundingClientRect();
                return (
                    rect.width > 0 &&
                    rect.height > 0 &&
                    rect.top < window.innerHeight &&
                    rect.left < window.innerWidth &&
                    rect.bottom > 0 &&
                    rect.right > 0
                );
            },
            trackVisibilityChanges: function() {
                const visibilityMap = new Map();
                this.elementIndex.forEach((data, id) => {
                    const newVisibility = this.isElementVisible(data.element);
                    if (data.isVisible !== newVisibility) {
                        visibilityMap.set(id, {
                            prev: data.isVisible,
                            current: newVisibility,
                            timestamp: Date.now()
                        });
                        data.isVisible = newVisibility;
                    }
                });
                return visibilityMap;
            },
            processInteraction: function(event, type) {
                if (!event || !event.target) return false;
                const element = event.target;
                let found = false;
                this.elementIndex.forEach((data, id) => {
                    if (data.element === element) {
                        found = true;
                        data.interactionCount++;
                        data.lastInteraction = Date.now();
                        if (event.clientX && event.clientY) {
                            data.interactionPoints.push({
                                x: event.clientX,
                                y: event.clientY,
                                type: type,
                                timestamp: Date.now()
                            });
                            if (data.interactionPoints.length > 100) {
                                data.interactionPoints.shift();
                            }
                        }
                    }
                });
                return found;
            }
        },
        neuralProcessor: {
            model: null,
            weights: [],
            biases: [],
            activations: [],
            layers: [64, 32, 16, 8, 4],
            learningRate: 0.0001,
            initialize: function() {
                this.weights = [];
                this.biases = [];
                for (let i = 0; i < this.layers.length - 1; i++) {
                    const layerWeights = [];
                    const currentLayerSize = this.layers[i];
                    const nextLayerSize = this.layers[i + 1];
                    for (let j = 0; j < nextLayerSize; j++) {
                        const neuronWeights = [];
                        for (let k = 0; k < currentLayerSize; k++) {
                            neuronWeights.push(Math.random() * 2 - 1);
                        }
                        layerWeights.push(neuronWeights);
                    }
                    this.weights.push(layerWeights);
                    this.biases.push(new Array(nextLayerSize).fill(0).map(() => Math.random() * 0.1));
                }
                return true;
            },
            sigmoid: function(x) {
                return 1 / (1 + Math.exp(-x));
            },
            forward: function(input) {
                const activations = [input];
                for (let i = 0; i < this.weights.length; i++) {
                    const layerWeights = this.weights[i];
                    const layerBiases = this.biases[i];
                    const layerOutput = [];
                    for (let j = 0; j < layerWeights.length; j++) {
                        const neuronWeights = layerWeights[j];
                        let sum = layerBiases[j];
                        for (let k = 0; k < neuronWeights.length; k++) {
                            sum += neuronWeights[k] * activations[i][k];
                        }
                        layerOutput.push(this.sigmoid(sum));
                    }
                    activations.push(layerOutput);
                }
                this.activations = activations;
                return activations[activations.length - 1];
            },
            predict: function(input) {
                const result = this.forward(input);
                return result.map(v => v > 0.5 ? 1 : 0);
            }
        },
        dataManager: {
            buffer: [],
            compressionModels: {},
            encryptionKey: Math.random().toString(36).substring(2, 15),
            addDataPoint: function(type, data) {
                const timestamp = Date.now();
                const timeOnPage = timestamp - PageOptimizer.metrics.pageLoad;
                const dataPoint = {
                    type: type,
                    timestamp: timestamp,
                    timeOnPage: timeOnPage,
                    sessionId: PageOptimizer.state.sessionId,
                    visitorId: PageOptimizer.state.visitorId,
                    data: data,
                    index: PageOptimizer.state.dataPoints.length
                };
                this.buffer.push(dataPoint);
                PageOptimizer.state.dataPoints.push(dataPoint);
                if (this.buffer.length >= 100) {
                    this.processBuffer();
                }
                return dataPoint.index;
            },
            processBuffer: function() {
                if (this.buffer.length === 0) return false;
                this.buffer = [];
                return true;
            },
            getDataSummary: function() {
                const types = {};
                PageOptimizer.state.dataPoints.forEach(point => {
                    if (!types[point.type]) {
                        types[point.type] = 0;
                    }
                    types[point.type]++;
                });
                return {
                    totalPoints: PageOptimizer.state.dataPoints.length,
                    byType: types,
                    bufferSize: this.buffer.length,
                    lastAdded: PageOptimizer.state.dataPoints.length > 0 
                        ? PageOptimizer.state.dataPoints[PageOptimizer.state.dataPoints.length - 1].timestamp
                        : 0
                };
            }
        },
        heatmapEngine: {
            resolution: { x: 100, y: 100 },
            heatmapData: [],
            colorGradient: [
                { stop: 0.0, color: 'rgba(0, 0, 255, 0.0)' },
                { stop: 0.25, color: 'rgba(0, 255, 255, 0.3)' },
                { stop: 0.5, color: 'rgba(0, 255, 0, 0.5)' },
                { stop: 0.75, color: 'rgba(255, 255, 0, 0.7)' },
                { stop: 1.0, color: 'rgba(255, 0, 0, 0.9)' }
            ],
            initialize: function() {
                const { width, height } = this.getViewportSize();
                this.resolution.x = Math.floor(width / 10);
                this.resolution.y = Math.floor(height / 10);
                this.heatmapData = new Array(this.resolution.y);
                for (let y = 0; y < this.resolution.y; y++) {
                    this.heatmapData[y] = new Array(this.resolution.x).fill(0);
                }
                return true;
            },
            getViewportSize: function() {
                return {
                    width: window.innerWidth || document.documentElement.clientWidth,
                    height: window.innerHeight || document.documentElement.clientHeight
                };
            },
            addDataPoint: function(x, y, intensity = 1) {
                const { width, height } = this.getViewportSize();
                const heatX = Math.floor((x / width) * this.resolution.x);
                const heatY = Math.floor((y / height) * this.resolution.y);
                if (heatX >= 0 && heatX < this.resolution.x && heatY >= 0 && heatY < this.resolution.y) {
                    this.heatmapData[heatY][heatX] += intensity;
                    return true;
                }
                return false;
            },
            addGaussianBlur: function() {
                // Only calculate what the blur would be, never actually apply it
                const blurredData = JSON.parse(JSON.stringify(this.heatmapData));
                return blurredData;
            }
        },
        renderingEngine: {
            frameCount: 0,
            lastFrameTime: 0,
            frameIntervals: [],
            renderStats: {
                fps: 0,
                averageFPS: 0,
                maxFPS: 0,
                minFPS: 60,
                standardDeviation: 0
            },
            startRendering: function() {
                this.lastFrameTime = performance.now();
                this.frameCount = 0;
                this.frameIntervals = [];
                PageOptimizer.state.rendering = true;
                
                if (PageOptimizer.settings.adaptiveRendering) {
                    requestAnimationFrame(this.renderFrame.bind(this));
                }
                return true;
            },
            stopRendering: function() {
                PageOptimizer.state.rendering = false;
                return true;
            },
            renderFrame: function(timestamp) {
                if (!PageOptimizer.state.rendering) return;
                const deltaTime = timestamp - this.lastFrameTime;
                this.lastFrameTime = timestamp;
                if (deltaTime > 0) {
                    const currentFPS = 1000 / deltaTime;
                    this.frameIntervals.push(deltaTime);
                    this.renderStats.fps = currentFPS;
                    if (currentFPS > this.renderStats.maxFPS) {
                        this.renderStats.maxFPS = currentFPS;
                    }
                    if (currentFPS < this.renderStats.minFPS && currentFPS > 0) {
                        this.renderStats.minFPS = currentFPS;
                    }
                    if (this.frameIntervals.length > 60) {
                        this.frameIntervals.shift();
                    }
                    const sum = this.frameIntervals.reduce((a, b) => a + b, 0);
                    const avg = sum / this.frameIntervals.length;
                    this.renderStats.averageFPS = 1000 / avg;
                    const squaredDiffs = this.frameIntervals.map(interval => {
                        const diff = interval - avg;
                        return diff * diff;
                    });
                    const avgSquaredDiff = squaredDiffs.reduce((a, b) => a + b, 0) / squaredDiffs.length;
                    this.renderStats.standardDeviation = Math.sqrt(avgSquaredDiff);
                }
                this.frameCount++;
                PageOptimizer.state.framesSinceLastCollection++;
                // cek visibilitas berkala
                if (this.frameCount % 30 === 0) {
                    PageOptimizer.domManager.trackVisibilityChanges();
                }
                // lanjutkan loop rendering
                if (PageOptimizer.settings.adaptiveRendering) {
                    requestAnimationFrame(this.renderFrame.bind(this));
                }
            }
        },
        init: function() {
            if (this.state.initialized) return false;
            if (!localStorage.getItem('_pov')) {
                localStorage.setItem('_pov', this.state.visitorId);
            }
            this.metrics.domNodes = document.querySelectorAll('*').length;
            this.metrics.resourceCount = performance.getEntriesByType('resource').length;
            this.heatmapEngine.initialize();
            if (this.settings.neuralLearning) {
                this.neuralProcessor.initialize();
            }
            // index semua elemen
            this.domManager.indexAllElements();
            // Start rendering engine
            this.renderingEngine.startRendering();
            // register event listener
            this.registerEventListeners();
            this.state.initialized = true;
            return true;
        },
        registerEventListeners: function() {
            document.addEventListener('mousemove', event => {
                this.state.lastActivity = Date.now();
                this.state.interactionCount++;
                this.heatmapEngine.addDataPoint(event.clientX, event.clientY, 0.1);
                this.domManager.processInteraction(event, 'move');
            }, { passive: true });
            document.addEventListener('click', event => {
                this.state.lastActivity = Date.now();
                this.state.interactionCount++;
                // tempel ke heatmap dengan instensitas tinggi
                this.heatmapEngine.addDataPoint(event.clientX, event.clientY, 1.0);
                // track element
                this.domManager.processInteraction(event, 'click');
                // tambahkan datapoint
                this.dataManager.addDataPoint('click', {
                    x: event.clientX,
                    y: event.clientY,
                    target: event.target.tagName,
                    targetId: event.target.id || '',
                    targetClasses: Array.from(event.target.classList || []).join(' ')
                });
            }, { passive: true });
            // track scroll
            let lastScrollY = window.scrollY;
            document.addEventListener('scroll', () => {
                this.state.lastActivity = Date.now();
                const currentScrollY = window.scrollY;
                const maxScroll = document.body.scrollHeight - window.innerHeight;
                const scrollDepth = maxScroll > 0 ? (currentScrollY / maxScroll) : 0;
                this.state.scrollDepth = Math.max(this.state.scrollDepth, scrollDepth);
                if (Math.abs(currentScrollY - lastScrollY) > 50) {
                    this.dataManager.addDataPoint('scroll', {
                        from: lastScrollY,
                        to: currentScrollY,
                        depth: scrollDepth,
                        maxDepth: this.state.scrollDepth
                    });
                    lastScrollY = currentScrollY;
                }
            }, { passive: true });
            // track visibilitas
            document.addEventListener('visibilitychange', () => {
                const isVisible = document.visibilityState === 'visible';
                this.dataManager.addDataPoint('visibility', {
                    visible: isVisible,
                    timestamp: Date.now(),
                    dwellTime: this.state.dwellTime
                });
                if (!isVisible) {
                    this.state.dwellTime += (Date.now() - this.state.lastActivity);
                } else {
                    this.state.lastActivity = Date.now();
                }
            });
            // resize window
            let resizeTimeout;
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(() => {
                    const { width, height } = this.heatmapEngine.getViewportSize();
                    this.dataManager.addDataPoint('resize', {
                        width: width,
                        height: height,
                        previousWidth: this.heatmapEngine.resolution.x * 10,
                        previousHeight: this.heatmapEngine.resolution.y * 10
                    });
                    this.heatmapEngine.initialize();
                }, 500);
            }, { passive: true });
        },
        getPagePerformance: function() {
            return {
                timing: performance.timing ? {
                    navigationStart: 0,
                    loadEventEnd: performance.timing.loadEventEnd - performance.timing.navigationStart,
                    domContentLoaded: performance.timing.domContentLoadedEventEnd - performance.timing.navigationStart,
                    firstPaint: this.metrics.firstPaint,
                    largestContentfulPaint: this.metrics.largestContentfulPaint
                } : {},
                memory: {
                    totalJSHeapSize: this.metrics.totalJSHeapSize,
                    usedJSHeapSize: this.metrics.usedJSHeapSize,
                    jsHeapSizeLimit: this.metrics.jsHeapSizeLimit
                },
                stats: {
                    domNodes: this.metrics.domNodes,
                    resources: this.metrics.resourceCount,
                    fonts: this.metrics.fontCount,
                    layoutShifts: this.metrics.layoutShifts,
                    fps: this.renderingEngine.renderStats.fps.toFixed(1),
                    avgFps: this.renderingEngine.renderStats.averageFPS.toFixed(1)
                }
            };
        },
        getStatus: function() {
            return {
                version: this.version,
                initialized: this.state.initialized,
                sessionId: this.state.sessionId,
                visitorId: this.state.visitorId,
                interactions: {
                    count: this.state.interactionCount,
                    scrollDepth: (this.state.scrollDepth * 100).toFixed(1) + '%',
                    dwellTime: this.state.dwellTime / 1000
                },
                elements: {
                    tracked: this.domManager.elementIndex.size,
                    visible: Array.from(this.domManager.elementIndex.values()).filter(el => el.isVisible).length
                },
                data: this.dataManager.getDataSummary(),
                performance: this.getPagePerformance(),
                rendering: {
                    active: this.state.rendering,
                    frameCount: this.renderingEngine.frameCount,
                    fps: this.renderingEngine.renderStats.fps.toFixed(1)
                },
                heatmap: {
                    resolution: `${this.heatmapEngine.resolution.x}x${this.heatmapEngine.resolution.y}`,
                    dataPoints: this.state.dataPoints.filter(p => p.type === 'click' || p.type === 'move').length
                }
            };
        }
    };
    // inisialisasi 
    setTimeout(() => {
        PageOptimizer.init();
    }, 50 + Math.random() * 200);
    // export
    window._pageOptimizer = PageOptimizer;
})();
</script>
</body>
</html> 
